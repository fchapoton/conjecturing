{"name":"Conjecturing","tagline":"","body":"# Conjecturing for Sage\r\n\r\nThis repository contains the code described in the paper Automated Conjecture-making: Fajtlowicz's Dalmatian Heuristic Revisited.\r\n\r\n## Quickstart\r\n\r\nSee the directory `spkg` for instructions on how to build and install a Sage package containing the expressions program.\r\nOnce you have built and installed such a Sage package, you can use the Python files in the directory `sage` to interact\r\nwith the package.\r\n\r\nOpen the directory `sage` in a terminal window and start Sage. Usually this is done using the following command:\r\n\r\n```\r\n$ sage\r\n```\r\n\r\nOnce Sage has started, you can load the file `conjecturing.py`:\r\n\r\n```\r\nsage: attach('conjecturing.py')\r\n```\r\n\r\nYou can also choose to load any of the other files, but this is not necessary.\r\n\r\nAn example run might look like this:\r\n\r\n```\r\nsage: attach('conjecturing.py')\r\nsage: attach('numbertheory.py')\r\nsage: objects = [5, 10]\r\nsage: conjecture(objects, invariants, 1)\r\n```\r\n\r\nNote that loading the file `numbertheory.py` sets the variable `invariants` to a list of invariants used in number theory.\r\n\r\n## Layout of the repository\r\n\r\nThe repository contains four directory:\r\n* `c`: this directory contains the code for the program expressions which is used to generate the expressions and conjectures. This program can also be used as a stand-alone program.\r\n* `spkg`: this directory contains the script needed to construct a Sage package of the C program, so that the program can easily be installed.\r\n* `sage`: this directory contains the Python scripts which integrate the C program into Sage.\r\n* `examples`: this directory contains several examples of how the code in this repository can be used.\r\n\r\n## Usage\r\n\r\n### C program \r\n\r\nBuilding the C program is simple: just execute the command `make` in the directory `c`. This will build the program `expressions`. A detailed usage message for `expressions` can be obtained by executing the following command:\r\n\r\n```\r\n$ ./expressions -h\r\n```\r\n\r\nIn the Sage code this program is used to generate the conjectures, but it can also be used to generate the intermediate structures.\r\n\r\nTo generate rooted binary trees with a 0 binary nodes (i.e., with two children) and with 1 unary node (i.e., with one child), you can use the following command:\r\n\r\n```\r\n$ ./expressions -u 1 0\r\nFound 1 unlabeled trees.\r\n```\r\n\r\nTo generate labeled rooted binary trees, you also have to specify the number of invariants (i.e., labels for the leaves):\r\n\r\n```\r\n$ ./expressions -l 1 0 2\r\nFound 1 unlabeled trees.\r\nFound 10 labeled trees.\r\n```\r\n\r\nTo generate valid expressions, you need to input the values of invariants for all objects. Assume that the content of the file `values.txt` is this:\r\n\r\n```\r\n3 4 2\r\n3\r\n3\r\n2\r\n2\r\n5\r\n5\r\n2\r\n2\r\n5\r\n10\r\n4\r\n4\r\n```\r\n\r\nThe first line tells us that there are 3 objects, 4 invariants and that the second invariant is the main invariant. This corresponds to the following situation:\r\n\r\n```\r\n           Invariant  1  Invariant  2  Invariant  3  Invariant  4\r\n object 1)    3.000000      3.000000      2.000000      2.000000\r\n object 2)    5.000000      5.000000      2.000000      2.000000\r\n object 3)    5.000000     10.000000      4.000000      4.000000\r\n```\r\n\r\nNow you can generate all valid expressions with one unary operator as follows:\r\n\r\n```\r\n$ ./expressions -e 1 0 --all-operators --print-valid-expressions < values.txt \r\nI2 <= (I1) * 2\r\nI2 <= (I1) ^ 2\r\nFound 1 unlabeled trees.\r\nFound 30 labeled trees.\r\nFound 2 valid expressions.\r\n```\r\n\r\nFinally you can also generate conjectures using the same file:\r\n\r\n```\r\n$ ./expressions -c --all-operators --dalmatian < values.txt \r\nGeneration process was stopped by the conjecturing heuristic.\r\nFound 5 unlabeled trees.\r\nFound 410 labeled trees.\r\nFound 53 valid expressions.\r\nI2 <= (I1) * 2\r\nI2 <= ((I1) / 2) * (I3)\r\nI2 <= ((I3) ^ 2) + 1\r\n```\r\n\r\n### Making the Sage Package\r\n\r\nYou do not need to make the Sage Package. You can simply install the one we are providing. If you however want to make the Sage Package yourself, simply go to the directory `spkg` and use the following command:\r\n\r\n```\r\n$ make conjecturing-YYYYMMDD.spkg\r\n```\r\n\r\nReplace `YYYYMMDD` by the year, the month and the day respectively. You can then install this newly created package by issueing the following command:\r\n\r\n```\r\n$ sage -f conjecturing-YYYYMMDD.spkg\r\n```\r\n\r\nDepending on the location where Sage is installed, you might need to add `sudo` at the beginning of that command.\r\n\r\n### Making conjectures in Sage\r\n\r\nOnce you have installed the Sage Package (either by downloading and installing it, or by building it yourself and then installing it), you can load the files in the directory `sage` to make conjectures within Sage. The most important file is `conjecturing.py`. This loads the code needed to make conjectures. The remaining files just provide utility methods to make conjectures for graph theory, matrix theory and number theory.\r\n\r\nSimply start Sage from the directory `sage` and once Sage is started, give the following command:\r\n\r\n```\r\nsage: load('conjecturing.py')\r\n```\r\n\r\nThis is all you need to do. From now on you can use the method `conjecture` to make conjectures. This method needs three arguments, and can take several additional optional arguments. The arguments that need to be provided are:\r\n\r\n* `objects`: the objects on which the conjectures will be based.\r\n* `invariants`: the invariants that can appear in the conjectures.\r\n* `mainInvariant`: the main invariant that will appear on the left-hand-side of the comparator.\r\n\r\nThese three are sufficient to make conjectures:\r\n\r\n```\r\nsage: def max_degree(g):\r\n....:    return max(g.degree())\r\n....:\r\nsage: invariants = [Graph.size, Graph.order, max_degree]\r\nsage: objects = [graphs.CompleteGraph(n) for n in [3,4,5]]\r\nsage: conjecture(objects, invariants, 0)\r\n[size(x) <= 2*order(x),\r\n size(x) <= max degree(x)^2 - 1,\r\n size(x) <= 1/2*order(x)*max degree(x)]\r\n```\r\n\r\nThe optional arguments are:\r\n\r\n* `upperBound`: if `True`, the conjectures are upper bounds for the main invariant. Default value is `True`.\r\n* `time`: specifies the amount of seconds after which the heuristic decides to no longer look for new conjectures. Default value is 5.\r\n* `variableName`: specifies the symbol to be used for a general object in the conjectures. Default value is 'x'.\r\n* `debug`: if `True`, the output of the program `expressions` to stderr is printed. Default value is `False`.\r\n* `verbose`: if `True`, the program `expressions` is ran in verbose mode. Note that this has no point if `debug` is `False`. Default value is `False`.\r\n* `operators`: specifies a set of operators that can be used. If this is `None`, then all operators are used. Otherwise only the specified operators are used. It is advised to use the method `allOperators` to get a set containing all operators and then removing the operators you don't need. Default value is `None`.\r\n* `theory`: specifies a list of known bounds. If this is `None`, then no known bounds are used. Otherwise each conjecture will have to be more significant than the bounds in this list. This implies that if each object obtains equality for any of the bounds in this list, then no conjectures will be made.\r\n\r\n### Running the examples\r\n\r\nEach of the examples in the directory `examples` specify which files need to be loaded for the example to work. The examples are referred to from the paper. Most of the examples come in two versions: a short and a long version. The short version immediately should give the conjectures as they appear in the paper. Since in most cases the conjecturing is halted by the time limit, in some cases there might be a small discrepancy between the conjectures in the paper and the conjectures you get. The long version repeats the steps we took to produce the conjectures, i.e., start with a small set, generate conjectures, look for counterexamples, add them to the objects, generate conjectures, ... Note that these long versions sometimes take very long (some need multiple days!).\r\n\r\nFor example, to run the first example of goldbach conjectures, you proceed as follows. Start Sage in the directory `examples`. Execute the following commands:\r\n\r\n```\r\nsage: load('../sage/conjecturing.py')\r\nsage: load('../sage/numbertheory.py')   \r\nsage: load('goldbach_conjectures1.py')\r\nThe conjectures are stored in the variable conjectures.\r\nsage: conjectures\r\n[goldbach(x) >= (1/digits10(x)), goldbach(x) >= digits10(x) - 1]\r\n```\r\n\r\nIf you want to run the long version, then you load the file which has -long appended to the name:\r\n\r\n```\r\nsage: load('../sage/conjecturing.py') \r\nsage: load('../sage/numbertheory.py') \r\nsage: load('goldbach_conjectures1-long.py')   \r\nStarting with these objects:\r\n 4\r\n\r\nAvailable invariants:\r\n   goldbach\r\n   prime_pi\r\n   euler_phi\r\n   number\r\n   digits10\r\n   digits2\r\n   sigma\r\n   count_divisors\r\n   next_prime\r\n   previous_prime\r\n   count_quadratic_residues\r\n   mertens\r\n   li\r\n   zeta\r\n   reciprocal_prime_sum\r\n   max_prime_divisor\r\n   prime_product\r\n\r\nFound the following conjectures:\r\n goldbach(x) >= digits10(x)\r\n\r\nStep 1: Adding 12\r\nFound the following conjectures:\r\n goldbach(x) >= (1/digits10(x))\r\n goldbach(x) >= digits10(x) - 1\r\n\r\nNo counterexample found\r\nThe conjectures are stored in the variable conjectures.\r\nsage: conjectures\r\n[goldbach(x) >= (1/digits10(x)), goldbach(x) >= digits10(x) - 1]\r\n```\r\n\r\nNote that this will take quite long to verify these two conjectures for all values it checks.\r\n\r\n## Conjecturing on SageMathCloud &trade;\r\n\r\nOne easy way to work with Sage is by going to http://cloud.sagemath.com. Of course you can use our code on SageMathCloud &trade;. By default, however, it is not possible to install additional packages there, so we created a separate release of the conjecturing package which can easily be used on SMC.\r\n\r\n* Download the [0.9-SMC release](https://github.com/nvcleemp/conjecturing/archive/0.9-SMC.zip).\r\n* Create a new project on SMC, and upload the zip file from the previous step to that project.\r\n* Open a terminal on SMC and execute the following commands:\r\n```\r\n~$ unzip conjecturing-0.9-SMC\r\n~$ cd conjecturing-0.9-SMC\r\n~/conjecturing-0.9-SMC$ make\r\n```\r\n* You are done. You can now start conjecturing using a Terminal or a Sage Worksheet. You can just follow the instructions above. In case you are bothered by the zip file and the directory 0.9-SMC, you can just remove them. Do not remove the files `expressions` and `conjecturing.py`.\r\n\r\nYou can check that the installation was successful by creating a worksheet, copying the code below and executing it. If everything went OK, you should see some conjectures.\r\n\r\n```\r\nload('conjecturing.py')\r\ndef max_degree(g):\r\n    return max(g.degree())\r\ninvariants = [Graph.size, Graph.order, max_degree]\r\nobjects = [graphs.CompleteGraph(n) for n in [3,4,5]]\r\nconjecture(objects, invariants, 0)\r\n```\r\n\r\nTo update to a newer version, you just repeat the steps above for the newer zip file.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}